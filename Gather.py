import time
import Meridian
class gather(float dist, ems):
	''''
	Not so high it passes through the physical matter but not so low it destroys any potential life forms. Further more, we now have to calculate delay times as such assume scanner is point zero in e_spheres class (satellite). The technology already exists, it was used to scan the subsurface of Egypt when looking for lost cities (saw that on a documentary). Good to try and write it out though.
	''''
	# Distance from surface
	
	dist = 0
	
	def surf_dist(dist):
		if dist <= 0:
			dist = dist()
		else:
			dist = dist
	float e = 5e-5
	''''
	Perhaps some virtualised models to test with.
	float EMS = 
	
	NIR	Near infrared	10 μm	30 THz	124 meV
	    MIR	Mid infrared	100 μm	3 THz	12.4 meV
	
	FIR	Far infrared	 1 mm	300 GHz	1.24 meV
	    EHF	Extremely high	 1 cm	30 GHz	124 μeV
		frequency
	
	#float EMS = 0 Ionizing SX	Soft X-rays	1 nm 300 PHz	1.24 keV
	EUV which is 1 - 10nm 30 - 30 PHz 1.24 - 124ev synchronously apparently lightning storms with the ionizing spectrum in an ionosphere, thoughts on primordial soup anyone? https://img-s-msn-com.akamaized.net/tenant/amp/entityid/BB1ezouY.img?h=532&w=799&m=6&q=60&o=f&l=f
	
	From <https://en.wikipedia.org/wiki/Electromagnetic_spectrum> 
	
	Else preferred, another alternative, safer, is infrared and near infrared (Above)- less likely to cause damage. Could still yield the desired accuracy if the information in the reference is correct. However, The concern here is the concentration and amplification values. (any signal is safe at low enough amplification) dissipation over distance and time. Refer to isotopes in quartz watches and RSA tokens as an example. 
	
	Other considerations are energy efficiency. See notes in SpaceX hypotheticallities transceiver
	
	NEEDS SOME WORK
	''''
	def sigmoid(s):
		(1 / (1 + (pow(e, -s)))
	# Attempt at reverse engineering
	def rev_sigmoid(s):
		((pow(-e, s)) - 1) * -1)
		
	def dist():
	clock()
	b_sent = sigmoid(EMS)
	
	b_recd = rev_sigmoid(s)
	initial_distance = ((clock() / 299792458) / 2)
	return
	
	def blip():
		# start cpu clock timer and send ems
		clock()
		b_sent = sigmoid(EMS)
		''''
		Have to reverse engineer the signal received 
		if the value is 0 we have the same signal
		''''
		b_recd = rev_sigmoid(s) # where s is the input from the emp register see sxh
		# wait for same signal and stop
		if b_recd == 0:
			meridian.surf_rads(distance = (((clock() / 299,792,458) / 2) - dist)
			blip()
		else:
			continue
	''''
	Take first measurement for distance
	(preferred as opposed to scanning each lon over lat) pick the equator point and take a photo (reference point), begin lat scan and thrust in opposing direction to rotation on lon axis, once at the same point in photo reference, become stationary process data and circumference based on opt_surf_rad(), based on time delays and geoforce of zero point. thrust (has to be slow enough to get each meridian per lat per full rotation on lon axis) on lon for duration of circumference according to lat rotation of sphere and until reaching image reference. Once reaching the final image reference, stop the scanning process and finish the computations.
	''''
	''''
	Speed of light in vacuum
	From <https://www.bing.com/search?q=speed+of+light+in+vaccum&cvid=afff88102f394feea777d6091a893638&aqs=edge..69i57j0l6.3935j0j1&pglt=43&FORM=ANNTA1&PC=U531> 
	''''
