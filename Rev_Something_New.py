class rev_something_new(float **kwargs):
	float _PI_ = 3.141592653589793
	X = 0
	Y = 0
	Z = 0
	float n_x < X
	float n_y < Y
	float n_z < Z
	float p_x > X
	float p_y > Y
	float p_z > Z
	float n_rad < 0
	float p_rad > 0
	float n_circ < 0
	float p_circ > 0
	def rev_something_new(float **kwargs):
		if n_rad or p_rad:
			for n in pow((_PI_ * pow((n_rad or p_rad), ((n > 0) or (n < 0)))), (_PI_ * pow((n_rad or p_rad), ((n > 0) or (n < 0))))):
				for v in (_PI_ * pow((n_rad or p_rad), ((n > 0) or (n < 0)))):
					_PI_ / v
					for  i in pow((n_rad or p_rad), ((n > 0) or (n < 0))):
						i /= v
						for p in (_PI_ * pow((n_rad or p_rad), ((n > 0) or (n < 0)))):
							p = _PI_ / i 
							for  c in pow((n_rad or p_rad), ((n > 0) or (n < 0))):
								c /= p
		elif n_rad and p_rad:
			for n in pow((_PI_ * pow((n_rad and p_rad), ((n > 0) and (n < 0)))), (_PI_ * pow((n_rad and p_rad), ((n > 0) and (n < 0))))):
				for v in (_PI_ * pow((n_rad and p_rad), ((n > 0) and (n < 0)))):
					_PI_ / v
					for  i in pow((n_rad and p_rad), ((n > 0) and (n < 0))):
						i /= v
						for p in (_PI_ * pow((n_rad and p_rad), ((n > 0) and (n < 0)))):
							p = _PI_ / i 
							for  c in pow((n_rad and p_rad), ((n > 0) and (n < 0))):
								c /= p
		else:
			for n in pow((_PI_ * pow((n_rad, p_rad), ((n > 0), (n < 0)))), (_PI_ * pow((n_rad, p_rad), ((n > 0) and (n < 0))))):
				for v in (_PI_ * pow((n_rad, p_rad), ((n > 0), (n < 0)))):
					_PI_ / v
					for  i in pow((n_rad, p_rad), ((n > 0), (n < 0))):
						i /= v
						for p in (_PI_ * pow((n_rad, p_rad), ((n > 0), (n < 0)))):
							p = _PI_ / i 
							for  c in pow((n_rad, p_rad), ((n > 0), (n < 0))):
								c /= p
			 
''''
Could try math.log()
Log functions in Python - GeeksforGeeks
These functions are the logarithms, and they are fundamentally important. For a=bca=bc (where b>0b>0) we write:
c=logba,c=logb⁡a,
which we can take to be the definition of logblogb. We read the operation as "logarithm, base bb," or "base bb logarithm".
In particular, we have
loga(ab)=bandalogab=b.loga⁡(ab)=bandaloga⁡b=b.
Of special interest is the natural logarithm, denoted by lnln or loglog, the logarithm of base ee. (NB that sometimes loglog can also denote base 1010, or base 22, depending on context.)
Logarithmic identities correspond to exponential identities. From example, from the definition we can conclude that
logb(pq)=logbp+logbqlogb⁡(pq)=logb⁡p+logb⁡q
(for p,q>0p,q>0), which corresponds to the identity bpq=bpbqbpq=bpbq.
Perhaps counterintuitively, sometimes it is convenient to define the natural logarithm first and then define the exponential function x↦exx↦ex to be its inverse, which leads to the slightly antiquated name antilog for an exponential function x↦bxx↦bx.

From <https://math.stackexchange.com/questions/956776/whats-the-inverse-operation-of-exponents> 
''''
